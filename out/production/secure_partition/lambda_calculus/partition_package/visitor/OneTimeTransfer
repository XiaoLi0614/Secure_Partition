from z3 import *

s = Optimize()

def solve(constr):
    s.add(constr)
    if s.check() == sat:
        return True
    else: 
        return False

def cLe(c1, c2):
    constraints = []
    for i1 in range(n):
        #constraints.append(And(Implies(c2[i1], c1[i1])))
        constraints.append(Implies(c2[i1], c1[i1]))
    result = And(constraints)
    return result

def cLeH (c1, h):
    constraints = []
    for i1 in range(n):
        #constraints.append(And(Implies(h[i1] > 0, c1[i1])))
        constraints.append(Implies(h[i1] > 0, c1[i1]))
    result = And(constraints)
    return result

def nonCheck(qs):
    constraints = []
    for i1 in range(n):
        #constraints.append(And(qs[i1] == 0))
        constraints.append(qs[i1] == 0)
    result = And(constraints)
    return result

def sLe(qs1, qs2):
    constraints = []
    for i1 in range(n):
        #constraints.append(And(qs2[i1] >= qs1[i1]))
        constraints.append(qs2[i1] >= qs1[i1])
    result = And(constraints)
    return result

def sL(qs1, qs2):
    constraints = []
    for i1 in range(n):
        constraints.append(qs1[i1] < qs2[i1])
    result = Implies(Not(nonCheck(qs2)), Or(constraints))
    return result

def bLe(q1, q2):
    constraints = []
    for i1 in range(n):
        subconstr = []
        for i2 in range(n):
            subconstr.append(sLe(q1[i1], q2[i2]))   
        constraints.append(Or(subconstr))
    result = And(constraints)
    return result

def confQ(c, q):
    constraints = []
    for i1 in range(n):
        for i2 in range(n):
            constraints.append(Implies(q[i1][i2] > 0, c[i2]))
    result = And(constraints)
    return result

#There are two solutions about representation of the Q matrix:
#1. the nonCheck can be eliminated because of integrity constraint. Then we will have to deal with redundency
#2. add nonCheck and then [[4, 7, 1],[0, 0, 0],[0, 0, 0]] can exists
def availabilityC(b, q):
    constraints = []
    for i1 in range(n):
        subconstr = []
        for i2 in range(n):
            aliveQs = [ principals[i] - b[i1][i] for i in range(n) ]
            subconstr.append(And(sLe(q[i2], aliveQs), Not(nonCheck(q[i2]))))
        constraints.append(Or(subconstr))
    result = And(constraints)
    return result

def availabilityP(b, q, h):
    constraints = []
    for i1 in range(n):
        subconstr = []
        for i2 in range(n):
            alive = []
            for a in range(n):
                alive.append(Implies(h[a] > 0, q[i2][a] <= h[a] - b[i1][a]))
                alive.append(Implies(h[a] == 0, q[i2][a] <= 0))
                #alive.append(Implies(q[i2][a] >= 0, q[i2][a] <= h[a] - b[i1][a]))
            subconstr.append(And(sLe(q[i2], h), Not(nonCheck(q[i2])), And(alive)))
        constraints.append(Or(subconstr))
    result = And(constraints)
    return result

def cIntegrity(b, q):
    constraints = []
    for i1 in range(n):
        subconstr = []
        for i2 in range(n):
            alive = []
            for a in range(n):
                #alive.append(Implies(a < n-1, b[i1][a] < q[i2][a]))
                alive.append(And(a < n-1, b[i1][a] < q[i2][a]))
            #subconstr.append(Implies(Not(nonCheck(q[i2])), And(alive)))
            subconstr.append(Implies(Not(nonCheck(q[i2])), Or(alive)))
        constraints.append(And(subconstr))
    result = And(constraints)
    return result

def cIntegrityE(b, q):
    constraints = []
    for i1 in range(n):
        subconstr = []
        for i2 in range(n):
            alive = []
            for a in range(n):
                alive.append(b[i1][a] < q[i2][a])
            subconstr.append(Implies(Not(nonCheck(q[i2])), Or(alive)))
        constraints.append(And(subconstr))
    result = And(constraints)
    return result

def sIntegrity(b, q):
    constraints = []
    for i3 in range(n):
        for i1 in range(n):
            for i2 in range(n):
                for j in range(n):
                    constraints.append(Implies(And(Not(q[i1][j] == 0), Not(q[i2][j] == 0)), 
                                               ((q[i1][j] + q[i2][j] - principals[j]) > b[i3][j])))
    result = And(constraints)
    return result

def lableLe(c1, c2, i1, i2, a1, a2):
    return And(cLe(c1, c2), bLe(i2, i1), bLe(a2, a1))


n = 3
principals = [ 4, 7, 1]
xC = [ True, True, True ]
xI = [ [ Int("xI_%s_%s" % (i, j)) for j in range(n) ] for i in range(n) ]
xIrange0 = [ And(0 <= xI[i][j]) for i in range(n) for j in range(n) ]
s.add(xIrange0)
xIrange1 = [And(sLe(xI[i], principals)) for i in range(n)]
s.add(xIrange1)
xA = [ [ Int("xA_%s_%s" % (i, j)) for j in range(n) ] for i in range(n) ]
xArange0 = [ And(0 <= xA[i][j]) for i in range(n) for j in range(n) ]
s.add(xArange0)
xArange1 = [And(sLe(xA[i], principals)) for i in range(n)]
s.add(xArange1)
startC = [ True, True, True ]
startI = [[ 4, 7, 0], [ 0, 0, 0], [ 0, 0, 0] ]
startA = [[ 4, 7, 0], [ 0, 0, 0], [ 0, 0, 0] ]
botC = [ True, True, True ]
botI = [[ 4, 7, 0], [ 0, 0, 0], [ 0, 0, 0] ]
botA = [[ 4, 7, 0], [ 0, 0, 0], [ 0, 0, 0] ]
resultC = [ False, False, True ]
resultI = [[ 1, 2, 0], [ 0, 0, 0], [ 0, 0, 0] ]
resultA = [[ 1, 2, 0], [ 0, 0, 0], [ 0, 0, 0] ]
resH = [ 0, 0, 1]
resQ = [ [ Int("resQ_%s_%s" % (i, j)) for j in range(n) ] for i in range(n) ]
s.add([ And(0 <= resQ[i][j]) for i in range(n) for j in range(n) ])
s.add([ And(sLe(resQ[i], principals)) for i in range(n) ])
m0H = [ Int('m0H_%s' % i) for i in range(n) ] 
m0Q = [ [ Int('m0Q_%s_%s' % (i, j)) for j in range(n) ] for i in range(n) ]
m0conxtC = [ Bool('m0conxtC_%s' % i) for i in range(n) ]
m0conxtI = [ [ Int('m0conxtI_%s_%s' % (i, j)) for j in range(n) ] for i in range(n) ]
m0conxtA = [ [ Int('m0conxtA_%s_%s' % (i, j)) for j in range(n) ] for i in range(n) ]
m0botC = [ Bool('m0botC_%s' % i) for i in range(n) ]
m0botI = [ [ Int('m0botI_%s_%s' % (i, j)) for j in range(n) ] for i in range(n) ]
m0botA = [ [ Int('m0botA_%s_%s' % (i, j)) for j in range(n) ] for i in range(n) ]
m0range0 = [ And(0 <= m0conxtI[i][j], 0 <= m0conxtA[i][j], 0 <= m0Q[i][j], 0 <= m0botI[i][j], 0 <= m0botA[i][j]) for i in range(n) for j in range(n) ]
s.add(m0range0)
m0range1 = [And(sLe(m0conxtI[i], principals), sLe(m0conxtA[i], principals), sLe(m0Q[i], principals), sLe(m0botI[i], principals), sLe(m0botA[i], principals)) for i in range(n)]
s.add(m0range1)
m0range2 = [And(0 <= m0H[i]) for i in range(n)]
s.add(m0range2)
s.add(sLe(m0H, principals))
s.add(Not(nonCheck(m0H)))
m1H = [ Int('m1H_%s' % i) for i in range(n) ] 
m1Q = [ [ Int('m1Q_%s_%s' % (i, j)) for j in range(n) ] for i in range(n) ]
m1conxtC = [ Bool('m1conxtC_%s' % i) for i in range(n) ]
m1conxtI = [ [ Int('m1conxtI_%s_%s' % (i, j)) for j in range(n) ] for i in range(n) ]
m1conxtA = [ [ Int('m1conxtA_%s_%s' % (i, j)) for j in range(n) ] for i in range(n) ]
m1botC = [ Bool('m1botC_%s' % i) for i in range(n) ]
m1botI = [ [ Int('m1botI_%s_%s' % (i, j)) for j in range(n) ] for i in range(n) ]
m1botA = [ [ Int('m1botA_%s_%s' % (i, j)) for j in range(n) ] for i in range(n) ]
m1range0 = [ And(0 <= m1conxtI[i][j], 0 <= m1conxtA[i][j], 0 <= m1Q[i][j], 0 <= m1botI[i][j], 0 <= m1botA[i][j]) for i in range(n) for j in range(n) ]
s.add(m1range0)
m1range1 = [And(sLe(m1conxtI[i], principals), sLe(m1conxtA[i], principals), sLe(m1Q[i], principals), sLe(m1botI[i], principals), sLe(m1botA[i], principals)) for i in range(n)]
s.add(m1range1)
m1range2 = [And(0 <= m1H[i]) for i in range(n)]
s.add(m1range2)
s.add(sLe(m1H, principals))
s.add(Not(nonCheck(m1H)))
m2H = [ Int('m2H_%s' % i) for i in range(n) ] 
m2Q = [ [ Int('m2Q_%s_%s' % (i, j)) for j in range(n) ] for i in range(n) ]
m2conxtC = [ Bool('m2conxtC_%s' % i) for i in range(n) ]
m2conxtI = [ [ Int('m2conxtI_%s_%s' % (i, j)) for j in range(n) ] for i in range(n) ]
m2conxtA = [ [ Int('m2conxtA_%s_%s' % (i, j)) for j in range(n) ] for i in range(n) ]
m2xC = [ Bool('m2xC_%s' % i) for i in range(n) ]
m2xI = [ [ Int('m2xI_%s_%s' % (i, j)) for j in range(n) ] for i in range(n) ]
m2xA = [ [ Int('m2xA_%s_%s' % (i, j)) for j in range(n) ] for i in range(n) ]
m2range0 = [ And(0 <= m2conxtI[i][j], 0 <= m2conxtA[i][j], 0 <= m2Q[i][j], 0 <= m2xI[i][j], 0 <= m2xA[i][j]) for i in range(n) for j in range(n) ]
s.add(m2range0)
m2range1 = [And(sLe(m2conxtI[i], principals), sLe(m2conxtA[i], principals), sLe(m2Q[i], principals), sLe(m2xI[i], principals), sLe(m2xA[i], principals)) for i in range(n)]
s.add(m2range1)
m2range2 = [And(0 <= m2H[i]) for i in range(n)]
s.add(m2range2)
s.add(sLe(m2H, principals))
s.add(Not(nonCheck(m2H)))
m3H = [ Int('m3H_%s' % i) for i in range(n) ] 
m3Q = [ [ Int('m3Q_%s_%s' % (i, j)) for j in range(n) ] for i in range(n) ]
m3conxtC = [ Bool('m3conxtC_%s' % i) for i in range(n) ]
m3conxtI = [ [ Int('m3conxtI_%s_%s' % (i, j)) for j in range(n) ] for i in range(n) ]
m3conxtA = [ [ Int('m3conxtA_%s_%s' % (i, j)) for j in range(n) ] for i in range(n) ]
m3xC = [ Bool('m3xC_%s' % i) for i in range(n) ]
m3xI = [ [ Int('m3xI_%s_%s' % (i, j)) for j in range(n) ] for i in range(n) ]
m3xA = [ [ Int('m3xA_%s_%s' % (i, j)) for j in range(n) ] for i in range(n) ]
m3range0 = [ And(0 <= m3conxtI[i][j], 0 <= m3conxtA[i][j], 0 <= m3Q[i][j], 0 <= m3xI[i][j], 0 <= m3xA[i][j]) for i in range(n) for j in range(n) ]
s.add(m3range0)
m3range1 = [And(sLe(m3conxtI[i], principals), sLe(m3conxtA[i], principals), sLe(m3Q[i], principals), sLe(m3xI[i], principals), sLe(m3xA[i], principals)) for i in range(n)]
s.add(m3range1)
m3range2 = [And(0 <= m3H[i]) for i in range(n)]
s.add(m3range2)
s.add(sLe(m3H, principals))
s.add(Not(nonCheck(m3H)))
aqs = [ [ Int("aqs_%s_%s" % (i, j)) for j in range(n) ] for i in range(n) ]
aqc = [ [ Int("aqc_%s_%s" % (i, j)) for j in range(n) ] for i in range(n) ]
areadbotC = [ Bool('areadbotC_%s' % i) for i in range(n) ]
areadbotI = [ [ Int("areadbotI_%s_%s" % (i, j)) for j in range(n) ] for i in range(n) ]
areadbotA = [ [ Int("areadbotA_%s_%s" % (i, j)) for j in range(n) ] for i in range(n) ]
areadoutputC = [ Bool('areadoutputC_%s' % i) for i in range(n) ]
areadoutputI = [ [ Int("areadoutputI_%s_%s" % (i, j)) for j in range(n) ] for i in range(n) ]
areadoutputA = [ [ Int("areadoutputA_%s_%s" % (i, j)) for j in range(n) ] for i in range(n) ]
awriteinput0C = [ Bool('awriteinput0C_%s' % i) for i in range(n) ]
awriteinput0I = [ [ Int("awriteinput0I_%s_%s" % (i, j)) for j in range(n) ] for i in range(n) ]
awriteinput0A = [ [ Int("awriteinput0A_%s_%s" % (i, j)) for j in range(n) ] for i in range(n) ]
awriteoutputC = [ Bool('awriteoutputC_%s' % i) for i in range(n) ]
awriteoutputI = [ [ Int("awriteoutputI_%s_%s" % (i, j)) for j in range(n) ] for i in range(n) ]
awriteoutputA = [ [ Int("awriteoutputA_%s_%s" % (i, j)) for j in range(n) ] for i in range(n) ]
arange0 = [ And(0 <= aqs[i][j], 0 <= aqc[i][j], 0 <= areadoutputI[i][j], 0 <= areadoutputA[i][j], 0 <= areadbotI[i][j], 0 <= areadbotA[i][j], 0 <= awriteoutputI[i][j], 0 <= awriteoutputA[i][j], 0 <= awriteinput0I[i][j], 0 <= awriteinput0A[i][j]) for i in range(n) for j in range(n) ]
s.add(arange0)
arange1 = [And(sLe(aqs[i], principals), sLe(aqc[i], principals), sLe(areadoutputI[i], principals), sLe(areadoutputA[i], principals), sLe(areadbotI[i], principals), sLe(areadbotA[i], principals), sLe(awriteoutputI[i], principals), sLe(awriteoutputA[i], principals), sLe(awriteinput0I[i], principals), sLe(awriteinput0A[i], principals)) for i in range(n)]
s.add(arange1)
arange2 = [And(0 == aqs[i][n-1]) for i in range(n)]
s.add(arange2)
i1qs = [ [ Int("i1qs_%s_%s" % (i, j)) for j in range(n) ] for i in range(n) ]
i1qc = [ [ Int("i1qc_%s_%s" % (i, j)) for j in range(n) ] for i in range(n) ]
i1readbotC = [ Bool('i1readbotC_%s' % i) for i in range(n) ]
i1readbotI = [ [ Int("i1readbotI_%s_%s" % (i, j)) for j in range(n) ] for i in range(n) ]
i1readbotA = [ [ Int("i1readbotA_%s_%s" % (i, j)) for j in range(n) ] for i in range(n) ]
i1readoutputC = [ True, False, True ]
i1readoutputI = [ [ Int("i1readoutputI_%s_%s" % (i, j)) for j in range(n) ] for i in range(n) ]
i1readoutputA = [ [ Int("i1readoutputA_%s_%s" % (i, j)) for j in range(n) ] for i in range(n) ]
i1range0 = [ And(0 <= i1qs[i][j], 0 <= i1qc[i][j], 0 <= i1readoutputI[i][j], 0 <= i1readoutputA[i][j], 0 <= i1readbotI[i][j], 0 <= i1readbotA[i][j]) for i in range(n) for j in range(n) ]
s.add(i1range0)
i1range1 = [And(sLe(i1qs[i], principals), sLe(i1qc[i], principals), sLe(i1readoutputI[i], principals), sLe(i1readoutputA[i], principals), sLe(i1readbotI[i], principals), sLe(i1readbotA[i], principals)) for i in range(n)]
s.add(i1range1)
i1range2 = [And(0 == i1qs[i][n-1]) for i in range(n)]
s.add(i1range2)
i2qs = [ [ Int("i2qs_%s_%s" % (i, j)) for j in range(n) ] for i in range(n) ]
i2qc = [ [ Int("i2qc_%s_%s" % (i, j)) for j in range(n) ] for i in range(n) ]
i2readbotC = [ Bool('i2readbotC_%s' % i) for i in range(n) ]
i2readbotI = [ [ Int("i2readbotI_%s_%s" % (i, j)) for j in range(n) ] for i in range(n) ]
i2readbotA = [ [ Int("i2readbotA_%s_%s" % (i, j)) for j in range(n) ] for i in range(n) ]
i2readoutputC = [ False, True, True ]
i2readoutputI = [ [ Int("i2readoutputI_%s_%s" % (i, j)) for j in range(n) ] for i in range(n) ]
i2readoutputA = [ [ Int("i2readoutputA_%s_%s" % (i, j)) for j in range(n) ] for i in range(n) ]
i2range0 = [ And(0 <= i2qs[i][j], 0 <= i2qc[i][j], 0 <= i2readoutputI[i][j], 0 <= i2readoutputA[i][j], 0 <= i2readbotI[i][j], 0 <= i2readbotA[i][j]) for i in range(n) for j in range(n) ]
s.add(i2range0)
i2range1 = [And(sLe(i2qs[i], principals), sLe(i2qc[i], principals), sLe(i2readoutputI[i], principals), sLe(i2readoutputA[i], principals), sLe(i2readbotI[i], principals), sLe(i2readbotA[i], principals)) for i in range(n)]
s.add(i2range1)
i2range2 = [And(0 == i2qs[i][n-1]) for i in range(n)]
s.add(i2range2)
#FieldT: a
s.add(confQ(areadoutputC, aqs))
s.add(sIntegrity(areadoutputI, aqs))
s.add(availabilityC(areadoutputA, aqs))
s.add(cIntegrityE(areadbotI, aqc))
s.add(lableLe(areadbotC, areadoutputC, areadbotI, areadoutputI, areadbotA, areadoutputA))
s.add(confQ(awriteoutputC, aqs))
s.add(sIntegrity(awriteoutputI, aqs))
s.add(availabilityC(awriteoutputA, aqs))
s.add(cIntegrityE(awriteinput0I, aqc))
s.add(lableLe(awriteinput0C, awriteoutputC, awriteinput0I, awriteoutputI, awriteinput0A, awriteoutputA))
#FieldT: i1
s.add(confQ(i1readoutputC, i1qs))
s.add(sIntegrity(i1readoutputI, i1qs))
s.add(availabilityC(i1readoutputA, i1qs))
s.add(cIntegrityE(i1readbotI, i1qc))
s.add(lableLe(i1readbotC, i1readoutputC, i1readbotI, i1readoutputI, i1readbotA, i1readoutputA))
#FieldT: i2
s.add(confQ(i2readoutputC, i2qs))
s.add(sIntegrity(i2readoutputI, i2qs))
s.add(availabilityC(i2readoutputA, i2qs))
s.add(cIntegrityE(i2readbotI, i2qc))
s.add(lableLe(i2readbotC, i2readoutputC, i2readbotI, i2readoutputI, i2readbotA, i2readoutputA))
#MethodT: ret
s.add(cLeH(resultC, resH))
s.add(cIntegrityE(resultI, resQ))
#MethodT: m0
m0botC = m0conxtC
m0botI = m0conxtI
m0botA = m0conxtA
#ObjCallT: let x8 = i1.read() in this.ret(x8)
s.add(cLeH(i1readoutputC, m0H))
s.add(availabilityP(i1readbotA, i1qc, m0H))
#ThisCallT: this.ret(x8)
s.add(cLe(m0conxtC, resultC))
s.add(bLe(resultI, m0conxtI))
s.add(bLe(resultA, m0conxtA))
s.add(cLe(i1readoutputC, resultC))
s.add(cLe(botC, resultC))
s.add(bLe(resultI, i1readoutputI))
s.add(bLe(resultI, botI))
s.add(bLe(resultA, i1readoutputA))
s.add(bLe(resultA, botA))
s.add(cLe(m0conxtC, resultC))
s.add(bLe(resultI, m0conxtI))
s.add(bLe(resultA, m0conxtA))
s.add(availabilityP(resultA, resQ, m0H))
s.add(cIntegrityE(m0botI, m0Q))
s.add(cLeH(m0botC, m0H))
s.add(cLeH(m0conxtC, m0H))
#MethodT: m1
m1botC = m1conxtC
m1botI = m1conxtI
m1botA = m1conxtA
#ObjCallT: let x9 = i2.read() in this.ret(x9)
s.add(cLeH(i2readoutputC, m1H))
s.add(availabilityP(i2readbotA, i2qc, m1H))
#ThisCallT: this.ret(x9)
s.add(cLe(m1conxtC, resultC))
s.add(bLe(resultI, m1conxtI))
s.add(bLe(resultA, m1conxtA))
s.add(cLe(i2readoutputC, resultC))
s.add(cLe(botC, resultC))
s.add(bLe(resultI, i2readoutputI))
s.add(bLe(resultI, botI))
s.add(bLe(resultA, i2readoutputA))
s.add(bLe(resultA, botA))
s.add(cLe(m1conxtC, resultC))
s.add(bLe(resultI, m1conxtI))
s.add(bLe(resultA, m1conxtA))
s.add(availabilityP(resultA, resQ, m1H))
s.add(cIntegrityE(m1botI, m1Q))
s.add(cLeH(m1botC, m1H))
s.add(cLeH(m1conxtC, m1H))
#MethodT: m2
#ObjCallT: let x10 = a.write(1) in If (x) then (let x8 = i1.read() in this.ret(x8)) else (let x9 = i2.read() in this.ret(x9))
s.add(cLeH(awriteoutputC, m2H))
s.add(cLe(botC, awriteinput0C))
s.add(bLe(awriteinput0I, botI))
s.add(bLe(awriteinput0A, botA))
s.add(availabilityP(awriteinput0A, aqc, m2H))
#IfT: If (x) then (this.m0()) else (this.m1())
#ThisCallT: this.m0()
s.add(cLe(m2conxtC, m0conxtC))
s.add(cLe(m2xC, m0conxtC))
s.add(cLe(botC, m0conxtC))
s.add(cLe(m2xC, m0conxtC))
s.add(cLe(botC, m0conxtC))
s.add(bLe(m0conxtI, m2conxtI))
s.add(bLe(m0conxtI, m2xI))
s.add(bLe(m0conxtI, botI))
s.add(bLe(m0conxtI, m2xI))
s.add(bLe(m0conxtI, botI))
s.add(bLe(m0conxtA, m2conxtA))
s.add(bLe(m0conxtA, m2xA))
s.add(bLe(m0conxtA, botA))
s.add(bLe(m0conxtA, m2xA))
s.add(bLe(m0conxtA, botA))
s.add(availabilityP(m0botA, m0Q, m2H))
s.add(cLe(m2conxtC, m0botC))
s.add(cLe(m2xC, m0botC))
s.add(cLe(botC, m0botC))
s.add(cLe(m2xC, m0botC))
s.add(cLe(botC, m0botC))
s.add(bLe(m0botI, m2conxtI))
s.add(bLe(m0botI, m2xI))
s.add(bLe(m0botI, botI))
s.add(bLe(m0botI, m2xI))
s.add(bLe(m0botI, botI))
s.add(bLe(m0botA, m2conxtA))
s.add(bLe(m0botA, m2xA))
s.add(bLe(m0botA, botA))
s.add(bLe(m0botA, m2xA))
s.add(bLe(m0botA, botA))
#ThisCallT: this.m1()
s.add(cLe(m2conxtC, m1conxtC))
s.add(cLe(m2xC, m1conxtC))
s.add(cLe(botC, m1conxtC))
s.add(cLe(m2xC, m1conxtC))
s.add(cLe(botC, m1conxtC))
s.add(bLe(m1conxtI, m2conxtI))
s.add(bLe(m1conxtI, m2xI))
s.add(bLe(m1conxtI, botI))
s.add(bLe(m1conxtI, m2xI))
s.add(bLe(m1conxtI, botI))
s.add(bLe(m1conxtA, m2conxtA))
s.add(bLe(m1conxtA, m2xA))
s.add(bLe(m1conxtA, botA))
s.add(bLe(m1conxtA, m2xA))
s.add(bLe(m1conxtA, botA))
s.add(availabilityP(m1botA, m1Q, m2H))
s.add(cLe(m2conxtC, m1botC))
s.add(cLe(m2xC, m1botC))
s.add(cLe(botC, m1botC))
s.add(cLe(m2xC, m1botC))
s.add(cLe(botC, m1botC))
s.add(bLe(m1botI, m2conxtI))
s.add(bLe(m1botI, m2xI))
s.add(bLe(m1botI, botI))
s.add(bLe(m1botI, m2xI))
s.add(bLe(m1botI, botI))
s.add(bLe(m1botA, m2conxtA))
s.add(bLe(m1botA, m2xA))
s.add(bLe(m1botA, botA))
s.add(bLe(m1botA, m2xA))
s.add(bLe(m1botA, botA))
s.add(cIntegrityE(m2xI, m2Q))
s.add(cLeH(m2xC, m2H))
s.add(cLeH(m2conxtC, m2H))
#MethodT: m3
#ObjCallT: let x12 = a.read() in If (x12) then (let x10 = a.write(1) in If (x) then (let x8 = i1.read() in this.ret(x8)) else (let x9 = i2.read() in this.ret(x9))) else (this.ret(0))
s.add(cLeH(areadoutputC, m3H))
s.add(availabilityP(areadbotA, aqc, m3H))
#IfT: If (x12) then (this.m2(x)) else (this.ret(0))
#ThisCallT: this.m2(x)
s.add(cLe(m3conxtC, m2conxtC))
s.add(cLe(areadoutputC, m2conxtC))
s.add(cLe(botC, m2conxtC))
s.add(cLe(areadoutputC, m2conxtC))
s.add(cLe(botC, m2conxtC))
s.add(bLe(m2conxtI, m3conxtI))
s.add(bLe(m2conxtI, areadoutputI))
s.add(bLe(m2conxtI, botI))
s.add(bLe(m2conxtI, areadoutputI))
s.add(bLe(m2conxtI, botI))
s.add(bLe(m2conxtA, m3conxtA))
s.add(bLe(m2conxtA, areadoutputA))
s.add(bLe(m2conxtA, botA))
s.add(bLe(m2conxtA, areadoutputA))
s.add(bLe(m2conxtA, botA))
s.add(cLe(m3xC, m2xC))
s.add(cLe(botC, m2xC))
s.add(bLe(m2xI, m3xI))
s.add(bLe(m2xI, botI))
s.add(bLe(m2xA, m3xA))
s.add(bLe(m2xA, botA))
s.add(cLe(m3conxtC, m2xC))
s.add(cLe(areadoutputC, m2xC))
s.add(cLe(botC, m2xC))
s.add(cLe(areadoutputC, m2xC))
s.add(cLe(botC, m2xC))
s.add(bLe(m2xI, m3conxtI))
s.add(bLe(m2xI, areadoutputI))
s.add(bLe(m2xI, botI))
s.add(bLe(m2xI, areadoutputI))
s.add(bLe(m2xI, botI))
s.add(bLe(m2xA, m3conxtA))
s.add(bLe(m2xA, areadoutputA))
s.add(bLe(m2xA, botA))
s.add(bLe(m2xA, areadoutputA))
s.add(bLe(m2xA, botA))
s.add(availabilityP(m2xA, m2Q, m3H))
#ThisCallT: this.ret(0)
s.add(cLe(m3conxtC, resultC))
s.add(cLe(areadoutputC, resultC))
s.add(cLe(botC, resultC))
s.add(cLe(areadoutputC, resultC))
s.add(cLe(botC, resultC))
s.add(bLe(resultI, m3conxtI))
s.add(bLe(resultI, areadoutputI))
s.add(bLe(resultI, botI))
s.add(bLe(resultI, areadoutputI))
s.add(bLe(resultI, botI))
s.add(bLe(resultA, m3conxtA))
s.add(bLe(resultA, areadoutputA))
s.add(bLe(resultA, botA))
s.add(bLe(resultA, areadoutputA))
s.add(bLe(resultA, botA))
s.add(cLe(botC, resultC))
s.add(bLe(resultI, botI))
s.add(bLe(resultA, botA))
s.add(cLe(m3conxtC, resultC))
s.add(cLe(areadoutputC, resultC))
s.add(cLe(botC, resultC))
s.add(cLe(areadoutputC, resultC))
s.add(cLe(botC, resultC))
s.add(bLe(resultI, m3conxtI))
s.add(bLe(resultI, areadoutputI))
s.add(bLe(resultI, botI))
s.add(bLe(resultI, areadoutputI))
s.add(bLe(resultI, botI))
s.add(bLe(resultA, m3conxtA))
s.add(bLe(resultA, areadoutputA))
s.add(bLe(resultA, botA))
s.add(bLe(resultA, areadoutputA))
s.add(bLe(resultA, botA))
s.add(availabilityP(resultA, resQ, m3H))
s.add(cIntegrityE(m3xI, m3Q))
s.add(cLeH(m3xC, m3H))
s.add(cLeH(m3conxtC, m3H))
s.add(cLe(startC, m3conxtC))
s.add(bLe(m3conxtI, startI))
s.add(bLe(m3conxtA, startA))
s.add(cLe(startC, m3xC))
s.add(bLe(m3xI, startI))
s.add(bLe(m3xA, startA))
s.add(cLe(m3xC, m3xC))
s.add(bLe(m3xI, m3xI))
s.add(bLe(m3xA, m3xA))
s.add(availabilityP(m3xA, m3Q, resH))

s.minimize(sum(m0H[i] * weight[i] for i in range(n)) + sum(m1H[i] * weight[i] for i in range(n)) + sum(m2H[i] * weight[i] for i in range(n)) + sum(m3H[i] * weight[i] for i in range(n)) + sum(aqs[0]) + sum(aqs[1]) + sum(aqs[2]) + sum(i1qs[0]) + sum(i1qs[1]) + sum(i1qs[2]) + sum(i2qs[0]) + sum(i2qs[1]) + sum(i2qs[2]) + sum(resQ[0]) + sum(resQ[1]) + sum(resQ[2]) + sum(m0Q[0]) + sum(m0Q[1]) + sum(m0Q[2]) + sum(m1Q[0]) + sum(m1Q[1]) + sum(m1Q[2]) + sum(m2Q[0]) + sum(m2Q[1]) + sum(m2Q[2]) + sum(m3Q[0]) + sum(m3Q[1]) + sum(m3Q[2]))
print(s.check())
m = s.model()
print("resH:")
print(resH)
print("m0H:")
print([m[hInfo].as_long() for hInfo in m0H])
print("m1H:")
print([m[hInfo].as_long() for hInfo in m1H])
print("m2H:")
print([m[hInfo].as_long() for hInfo in m2H])
print("m3H:")
print([m[hInfo].as_long() for hInfo in m3H])
print("resQ:")
print([e for qs in resQ for e in qs])
print([m[e].as_long() for qs in resQ for e in qs])
print("m0Q:")
print([e for qs in m0Q for e in qs])
print([m[e].as_long() for qs in m0Q for e in qs])
print("m1Q:")
print([e for qs in m1Q for e in qs])
print([m[e].as_long() for qs in m1Q for e in qs])
print("m2Q:")
print([e for qs in m2Q for e in qs])
print([m[e].as_long() for qs in m2Q for e in qs])
print("m3Q:")
print([e for qs in m3Q for e in qs])
print([m[e].as_long() for qs in m3Q for e in qs])
print("aqs:")
print([e for qs in aqs for e in qs])
print([m[e].as_long() for qs in aqs for e in qs])
print("i1qs:")
print([e for qs in i1qs for e in qs])
print([m[e].as_long() for qs in i1qs for e in qs])
print("i2qs:")
print([e for qs in i2qs for e in qs])
print([m[e].as_long() for qs in i2qs for e in qs])
