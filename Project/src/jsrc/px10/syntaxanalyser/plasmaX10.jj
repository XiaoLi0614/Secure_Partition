options {
  JAVA_UNICODE_ESCAPE = true;
}

PARSER_BEGIN(PlasmaX10Parser)
  package jsrc.px10.syntaxanalyser.parser;
  public class PlasmaX10Parser {}
PARSER_END(PlasmaX10Parser)

SKIP : /* WHITE SPACE */
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

SPECIAL_TOKEN : /* COMMENTS */
{
  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <FORMAL_COMMENT: "/**" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
| <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

TOKEN : 
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LSQPAREN: "[" >
| < RSQPAREN: "]" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < SEMICOLON: ";" >
| < DOT: "." >
| < ASSIGN: "=" >
| < LT: "<" >
| < PLUS: "+" >
| < MINUS: "-" >
| < AND : "&&" >   
| < NOT : "!" >   
| < QUESTION: "?" >   
| < CLASS: "class" >
| < VALUE: "value" >
| < FINAL: "final" >
| < IF: "if" >
| < ELSE: "else" >
| < FALSE: "false" >
| < TRUE: "true" >
| < WHILE: "while" >
| < VOID: "void" >
| < BOOLEAN: "boolean" >   
| < INTEGER: "int" >   
| < NEW: "new" >
| < GET: "get" >
| < CONTAINS: "contains" >
| < HIGH: "high" >
| < LOW: "low" >
| < NEXT: "next" >
| < PREV: "prev" >
| < ISFIRST: "isFirst" >
| < ISLAST: "isLast" >
| < COORD: "coord" >
| < ORDINAL: "ordinal" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < STATIC: "static" >
| < STRING: "String" >
| < THIS: "this" >
| < PRINTLN: "System.out.println" >
| < PRINT: "System.out.print" >
| < PRINTERROR: "System.err.println" >
| < CURRENTTIME: "System.currentTimeMillis" >
| < JAVAIOSIZE: "java.io.Integer.SIZE" >
| < FACTORYPlace: "dist.factory.place" >
| < FACTORYBlock: "dist.factory.block" >
| < FACTORYEMPTYREGION: "region.factory.emptyRegion" >
| < FACTORYPOINT: "point.factory.point" >
| < JAVALANGOBJECT: "java.lang.Object" >
| < BREAK: "break" >         
| < SUPER: "super" >         
| < THROW: "throw" >         
| < RUNTIMEEXCEPTION: "RuntimeException" >         
| < DOUBLE: "double" >         
| < LONG: "long" >         
| < SHORT: "short" >         
| < BYTE: "byte" >         
| < REGION: "region" >         
| < ID: "id" >         
| < PLACES: "place.places" >         
| < RANK: "rank" >         
| < DISTRIBUTION: "distribution" >         
| < DIST: "dist" >         
| < SWITCH: "switch" >         
| < ATEACH: "ateach" >         
| < FINISH: "finish" >         
| < MAIN: "main" >         
| < MATH: "Math" >         
| < SIN: "sin" >         
| < COS: "cos" >         
| < POW: "pow" >         
| < EXP: "exp" >         
| < SQRT: "sqrt" >         
| < ABS: "abs" >         
| < PLACE: "place" >         
| < MIN: "min" >         
| < MAX: "max" >         
| < LOG: "log" >         
| < SUM: "sum" >         
| < SIZE: "size" >         
| < EQUALS: "equals" >         
// | < TOSTRING: "toString" >         
| < PRIVATE: "private" >         
| < FOREACH: "foreach" >         
| < FINALLY: "finally" >         
| < POINT: "point" >         
| < CONTINUE: "continue" >         
| < INSTANCEOF: "instanceof" >         
| < DO: "do" >         
| < FOR: "for" >         
| < HERE: "here" >         
| < DISTUNIQUE: "dist.UNIQUE" >         
| < CASE: "case" >         
| < ASYNC: "async" >         
| < OR: "or" >         
| < DEFAULT_TOKEN: "default" >
}

TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL: ( ["1"-"9"] (["0"-"9"])* | "0" ) >
|
  < POINT_LITERAL:
        <DECIMAL_LITERAL> (["p","P"])
      | <HEX_LITERAL> (["p","P"])
      | <OCTAL_LITERAL> (["p","P"])
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < LONG_LITERAL: 
        <INTEGER_LITERAL> "L"
      | <HEX_LITERAL> "L"
  >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}

TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}



TOKEN :
{
  < RUNSIGNEDSHIFT: ">>>" >
| < RSIGNEDSHIFT: ">>" >
| < GT: ">" >
}

/* We use productions to match >>>, >> and > so that we can keep the
 * type declaration syntax with generics clean
 */


/*************************************
 * The PlasmaX10 Grammar Starts Here *
 *************************************/


void File() :
{}
{
  ( TopLevelDeclaration() )*
  <EOF>
}

void TopLevelDeclaration() :
{}
{
  LOOKAHEAD(12)
  MainClass() 
|
  LOOKAHEAD(2)
  ClassDeclaration() 
| 
  ValueDeclaration()
}

void MainClass() :
{}
{
  "public" "class" Identifier() "{"
    "public" "static" "void" "main" "(" "String" "[" "]" Identifier() ")"
    "{" Statement() "}"
  "}"
}


void ClassDeclaration() :
{}
{
  [ Public() ] "class" Identifier() "{" ( ClassMember() )* "}"
}

void ValueDeclaration() :
{}
{
  [ Public() ] "value" Identifier() "{" ( ValueMember() )* "}"
}

void ClassMember() :
{}
{
  LOOKAHEAD( "public" Identifier() "(" )
      ConstructorDeclaration() |
  LOOKAHEAD( MethodModifier() ReturnType() Identifier() "(" )
  MethodDeclaration() |
  LOOKAHEAD(2)
  ConstantDeclaration()
| 
  LOOKAHEAD(2)
  InitializableConstantDeclaration()
| 
  UpdatableFieldDeclaration() 
}

void ValueMember() :
{}
{
  LOOKAHEAD( "public" Identifier() "(" )
      ConstructorDeclaration() |
  LOOKAHEAD( MethodModifier() ReturnType() Identifier() "(" )
  MethodDeclaration() |
  LOOKAHEAD(2)
  ConstantDeclaration()
| 
  LOOKAHEAD(2)
  InitializableConstantDeclaration()
}

void ConstructorDeclaration() :
{}
{
  "public" Identifier()
  "(" ( FormalParameterList() )? ")"
  Block()
}

void Visibility() :
{}
{
  Public()
|
  Private() 
}

void ConstantDeclaration() :
{}
{
  Visibility() "static" "final" Type() Identifier() "=" Expression() ";"
}

void InitializableConstantDeclaration() :
{}
{
  Visibility() "final" Type() Identifier() ";"
}

void UpdatableFieldDeclaration() :
{}
{
  Visibility() Type() Identifier() ";"
}

void PublicStatic() :
{}
{
  "public" "static"
}

void Public() :
{}
{
  "public"
}

void Private() :
{}
{
  "private"
}

void MethodDeclaration() :  
{}
{
  MethodModifier() ReturnType() Identifier() 
  "(" ( FormalParameterList() )? ")" Block()
}

void MethodModifier() :
{}
{
  LOOKAHEAD( "public" "static" )
  PublicStatic()
|
  Public()
|
  Private()
}

void FormalParameterList() :
{}
{
  FormalParameter() ( FormalParameterRest() )*
}

void FormalParameter() :
{}
{
  FinalFormalParameter()
}

void FinalFormalParameter() :
{}
{
  ("final")? Type() Identifier()
}

void FormalParameterRest() :
{}
{
  "," FormalParameter()
}

void ReturnType() :
{}
{
  VoidType()
| 
  Type()
}

void VoidType() :
{}
{
  "void"
}

void Type() :
{}
{
  LOOKAHEAD( UpdatableArrayType() )
  UpdatableArrayType()
|
  LOOKAHEAD( ValueArrayType() )
  ValueArrayType()
|
  NonArrayType() 
}

void UpdatableArrayType() :
{}
{
  NonArrayType() "[" ":" RankEquation() ( DistributionEquation() )? "]"
}

void ValueArrayType() :
{}
{
  NonArrayType() "value" "[" ":" RankEquation() "]"
}

void RankEquation() :
{}
{
  "rank" "==" IntegerLiteral()
}

void DistributionEquation() :
{}
{
  "&&" "distribution" "==" Identifier() 
}

void NonArrayType() :
{}
{
  BooleanType()
|
  ByteType()
|
  ShortType()
|
  IntegerType()
| 
  LongType()
|
  DoubleType()
|
  StringType()
| 
  PlaceType()
| 
  DistType()
|
  RegionType() 
|
  PointType() 
|
  ClassNameType()     
}

void BooleanType() :
{}
{
  "boolean"
}

void ByteType() :
{}
{
  "byte"
}

void ShortType() :
{}
{
  "short"
}

void IntegerType() :
{}
{
  "int"
}


void LongType() :
{}
{
  "long"
}

void DoubleType() :
{}
{
  "double"
}

void StringType() :
{}
{
  "String"
}

void PlaceType() :
{}
{
  "place"
}

void DistType() :
{}
{
  "dist" "(" ":" RankEquation() ")"
}

void RegionType() :
{}
{
  "region" "(" ":" RankEquation() ")"
}

void PointType() :
{}
{
  "point" "(" ":" RankEquation() ")"
}

void ClassNameType() :
{}
{
  Identifier()
}

void Identifier() :
{}
{
  <IDENTIFIER> 
}


/*
 * Statement syntax follows.
 */

void Statement() :
{}
{
  LOOKAHEAD( Assignment() )
  Assignment()
|
  AsyncStatement()
|
  Block()
|
  BreakStatement()
|
  ContinueStatement()
|
  DoStatement()
|
  FinishStatement()
|
  IfStatement()
|
  LoopStatement()
|
  PostfixStatement()
|
  PrintlnStatement()
|
  PrintStatement()
|
  PrintErrorStatement()
|
  ReturnStatement()
|
  SwitchStatement()
|
  ThrowStatement()
|
  WhileStatement()
}

void Assignment() :
{}
{
  PrimaryExpression() "=" Expression() ";"
}

void AsyncStatement() :
{}
{
  "async" "(" Expression() ")" Block()
}

void Block() :
{}
{
  "{" ( BlockStatement() )* "}"
}

void BlockStatement() :
{}
{
  FinalVariableDeclaration() 
|
  LOOKAHEAD ( Type() Identifier() "=" )
  UpdatableVariableDeclaration() 
|
  Statement()
}

void FinalVariableDeclaration() :
{}
{
  "final" Type() Identifier() "=" Expression() ";" 
}

void UpdatableVariableDeclaration() :
{}
{
  Type() Identifier() "=" Expression() ";" 
}

void BreakStatement() :
{}
{
  "break" ";"
}

void ContinueStatement() :
{}
{
  "continue" ";"
}

void DoStatement() :
{}
{
  "do" Statement() "while" "(" Expression() ")" ";"
}

void FinishStatement() :
{}
{
  "finish" Statement()
}

void IfStatement() :
/*
 * The disambiguating algorithm of JavaCC automatically binds dangling
 * else's to the innermost if statement.  The LOOKAHEAD specification
 * is to tell JavaCC that we know what we are doing.
 */
{}
{
  "if" "(" Expression() ")" Statement() 
  [ LOOKAHEAD(1) ElseClause() ]
}

void ElseClause() :
{}
{
  "else" Statement()
}

void LoopStatement() :
{}
{
  LoopQualifier() "(" PointType() ExplodedSpecification() ":" Expression() ")" 
  Statement()
}

void LoopQualifier() :
{}
{
  Ateach() | For() | Foreach()
}

void Ateach() :
{}
{
  "ateach" 
}

void For() :
{}
{
  "for" 
}

void Foreach() :
{}
{
  "foreach" 
}

void ExplodedSpecification() :
{}
{
  LOOKAHEAD( Identifier() "[" )
  PointNameCoordinates()
|
  PointName()
|
  Coordinates()
}

void PointNameCoordinates() :
{}
{
  PointName() Coordinates()
}

void PointName() :
{}
{
  Identifier()
}

void Coordinates() :
{}
{
  "[" IdentifierList() "]"
}

void IdentifierList() :
{}
{
  Identifier() ( IdentifierRest() )* 
}

void IdentifierRest() :
{}
{
  "," Identifier()
}

void PostfixStatement() :
{}
{
  PostfixExpression() ";"
}

void PrintlnStatement() :
{}
{
  "System.out.println" "(" Expression() ")" ";"
}

void PrintStatement() :
{}
{
  "System.out.print" "(" Expression() ")" ";"
}

void PrintErrorStatement() :
{}
{
  "System.err.println" "(" Expression() ")" ";"
}

void ReturnStatement() :
{}
{
  "return" [ Expression() ] ";"
}

void SwitchStatement() :
{}
{
  "switch" "(" Expression() ")" "{" ( SwitchEntry() )* "}"
}

void SwitchEntry() :
{}
{
    SwitchLabel() ":" ( BlockStatement() )* 
}

void SwitchLabel() :
{}
{
  Case()
|
  Default()
}

void Case() :
{}
{
  "case" Expression()
}

void Default() :
{}
{
  "default"
}

void ThrowStatement() :
{}
{
  "throw" "new" "RuntimeException" "(" Expression() ")" ";"
}

void WhileStatement() :
{}
{
  "while" "(" Expression() ")" Statement()
}

/*
 * Expression syntax follows.
 */

void Expression() :
{}
{ 
  ConditionalExpression()
}

void ConditionalExpression() :
{}
{
  ConditionalOrExpression() [ ConditionalExpressionRest() ]
}

void ConditionalExpressionRest() :
{}
{
  "?" Expression() ":" Expression()
}

void ConditionalOrExpression() :
{}
{
  ConditionalAndExpression() ( ConditionalOrExpressionRest() )*
}

void ConditionalOrExpressionRest() :
{}
{
  "||" ConditionalAndExpression()
}

void ConditionalAndExpression() :
{}
{
  InclusiveOrExpression() ( ConditionalAndExpressionRest() )*
}

void ConditionalAndExpressionRest() :
{}
{
  "&&" InclusiveOrExpression()
}

void InclusiveOrExpression() :
{}
{
  ExclusiveOrExpression() ( InclusiveOrExpressionRest() )*
}

void InclusiveOrExpressionRest() :
{}
{
  "|" ExclusiveOrExpression() 
}

void ExclusiveOrExpression() :
{}
{
  AndExpression() ( ExclusiveOrExpressionRest() )*
}

void ExclusiveOrExpressionRest() :
{}
{
  "^" AndExpression() 
}

void AndExpression() :
{}
{
  EqualityExpression() ( AndExpressionRest() )*
}

void AndExpressionRest() :
{}
{
  "&" EqualityExpression() 
}

void EqualityExpression() :
{}
{
  RelationalExpression() ( EqualityExpressionRest() )?
}

void EqualityExpressionRest() :
{}
{
  EqualsExpression()
|
  NonEqualsExpression()
}

void EqualsExpression() :
{}
{
  "==" RelationalExpression()
}

void NonEqualsExpression() :
{}
{
  "!=" RelationalExpression()
}

void RelationalExpression() :
{}
{
  ShiftExpression() [ RelationalExpressionRest() ]
}

void RelationalExpressionRest() :
{}
{
  LessThanExpression()
|
  GreaterThanExpression()
|
  LessThanEqualExpression()
|
  GreaterThanEqualExpression()
}

void LessThanExpression() :
{}
{
  "<" ShiftExpression() 
}

void GreaterThanExpression() :
{}
{
  ">" ShiftExpression() 
}

void LessThanEqualExpression() :
{}
{
  "<=" ShiftExpression() 
}

void GreaterThanEqualExpression() :
{}
{
  ">=" ShiftExpression() 
}

void ShiftExpression() :
{}
{
  AdditiveExpression() ( ShiftExpressionRest() )*
}

void ShiftExpressionRest() :
{}
{
  ShiftLeftExpression()
|
  ShiftRightExpression()
|
  ShiftRightUnsignedExpression()
}

void ShiftLeftExpression() :
{}
{
  "<<" AdditiveExpression() 
}

void ShiftRightExpression() :
{}
{
  ">>" AdditiveExpression() 
}

void ShiftRightUnsignedExpression() :
{}
{
  ">>>" AdditiveExpression() 
}

void AdditiveExpression() :
{}
{
  MultiplicativeExpression() ( AdditiveExpressionRest() )*
}

void AdditiveExpressionRest() :
{}
{
  LOOKAHEAD( PlusOffset() )
  PlusOffset()
|
  PlusExpression() 
|
  MinusExpression() 
}

void PlusOffset() :
{}
{
  "+" "[" ExpressionList() "]"
}

void PlusExpression() :
{}
{
  "+" MultiplicativeExpression()
}

void MinusExpression() :
{}
{
  "-" MultiplicativeExpression()
}

void MultiplicativeExpression() :
{}
{
  MapExpression() ( MultiplicativeExpressionRest() )*
}

void MultiplicativeExpressionRest() :
{}
{
  LOOKAHEAD( TimesOffset() )
  TimesOffset()
|
  TimesExpression() 
|
  LOOKAHEAD( DivideOffset() )
  DivideOffset()
|
  DivideExpression()
|
  ModulusExpression() 
}

void TimesOffset() :
{}
{
  "*" "[" ExpressionList() "]"
}

void TimesExpression() :
{}
{
  "*" MapExpression() 
}

void DivideOffset() :
{}
{
  "/" "[" ExpressionList() "]"
}

void DivideExpression() :
{}
{
  "/" MapExpression() 
}

void ModulusExpression() :
{}
{
  "%" MapExpression() 
}

void MapExpression() :
{}
{
  RegionExpression() [ MapExpressionRest() ]
}

void MapExpressionRest() :
{}
{
  "->" UnaryExpression() 
}

void RegionExpression() :
{}
{
  RegionConstant()
|
  UnaryExpression() 
}

void RegionConstant() :
{}
{
  "[" ColonExpression() ( ColonRest() )* "]"
}

void ColonRest() :
{}
{
  "," ColonExpression()
}

void ColonExpression() :
{}
{
  LOOKAHEAD( Expression() ":" )
  ColonPair()
|
  Expression()
}

void ColonPair() :
{}
{
  Expression() ":" Expression()
}

void MathExpression() :
{}
{
  LOOKAHEAD(3)
  SinExpression()
|
  LOOKAHEAD(3)
  CosExpression()
|
  LOOKAHEAD(3)
  PowExpression()
|
  LOOKAHEAD(3)
  ExpExpression()
|
  LOOKAHEAD(3)
  SqrtExpression()
|
  LOOKAHEAD(3)
  AbsExpression()
|
  LOOKAHEAD(3)
  MinExpression()
|
  LOOKAHEAD(3)
  MaxExpression()
|
  LOOKAHEAD(3)
  LogExpression()
}


void SinExpression() :
{}
{
  "Math" "." "sin" "(" Expression() ")"
}

void CosExpression() :
{}
{
  "Math" "." "cos" "(" Expression() ")"
}

void PowExpression() :
{}
{
  "Math" "." "pow" "(" Expression() "," Expression() ")"
}

void ExpExpression() :
{}
{
  "Math" "." "exp" "(" Expression() ")"
}

void SqrtExpression() :
{}
{
  "Math" "." "sqrt" "(" Expression() ")"
}

void AbsExpression() :
{}
{
  "Math" "." "abs" "(" Expression() ")"
}

void MinExpression() :
{}
{
  "Math" "." "min" "(" Expression() "," Expression() ")"
}

void MaxExpression() :
{}
{
  "Math" "." "max" "(" Expression() "," Expression() ")"
}

void LogExpression() :
{}
{
  "Math" "." "log" "(" Expression() ")"
}

void UnaryExpression() :
{}
{
  UnaryPlusExpression()
|
  UnaryMinusExpression()
|
  PreIncrementExpression()
|
  PreDecrementExpression()
|
  ComplimentExpression()
|
  NotExpression()
|
  LOOKAHEAD( CoercionToIntExpression() )
  CoercionToIntExpression()
|
  LOOKAHEAD( CoercionToDoubleExpression() )
  CoercionToDoubleExpression()
|
  LOOKAHEAD( CoercionToLongExpression() )
  CoercionToLongExpression()
|
  LOOKAHEAD( CoercionToShortExpression() )
  CoercionToShortExpression()
|
  LOOKAHEAD( CoercionToByteExpression() )
  CoercionToByteExpression()
|
  LOOKAHEAD( TypeAnnotatedExpression() )
  TypeAnnotatedExpression()
|
  PostfixExpression()
}

void UnaryPlusExpression() :
{}
{
  "+" PrimaryExpression()
}

void UnaryMinusExpression() :
{}
{
  "-" PrimaryExpression()
}

void PreIncrementExpression() :
{}
{
  "++" PrimaryExpression()
}

void PreDecrementExpression() :
{}
{
  "--" PrimaryExpression()
}

void ComplimentExpression() :
{}
{
  "~" UnaryExpression()
}

void NotExpression() :
{}
{
  "!" UnaryExpression()
}

void CoercionToIntExpression() :
{}
{
  "(" "int" ")" UnaryExpression()
}

void CoercionToDoubleExpression() :
{}
{
  "(" "double" ")" UnaryExpression()
}

void CoercionToLongExpression() :
{}
{
  "(" "long" ")" UnaryExpression()
}

void CoercionToShortExpression() :
{}
{
  "(" "short" ")" UnaryExpression()
}

void CoercionToByteExpression() :
{}
{
  "(" "byte" ")" UnaryExpression()
}

void TypeAnnotatedExpression() :
{}
{
  "(" TypeAnnotation() ")" UnaryExpression()
}

void TypeAnnotation() :
{}
{
      LOOKAHEAD( UpdatableArrayType() ) UpdatableArrayType() 
|
      LOOKAHEAD( ValueArrayType() ) ValueArrayType() 
|
      LOOKAHEAD( DistType() )
      DistType()
|
      LOOKAHEAD( RegionType() )
      RegionType()
| 
      LOOKAHEAD( PointType() )
      PointType()
}

void PostfixExpression() :
{}
{
  LOOKAHEAD( PostIncrementExpression() )
  PostIncrementExpression()
|
  LOOKAHEAD( PostDecrementExpression() )
  PostDecrementExpression()
|
  PrimaryExpression()
| 
  Place()
|
  FactoryBlock()
|
  FactoryBlockCyclic()
|
  FactoryEmptyRegion()
|
  CurrentTime()
}

void PostIncrementExpression() :
{}
{
  PrimaryExpression() "++" 
}

void PostDecrementExpression() :
{}
{
  PrimaryExpression() "--"
}

void PrimaryExpression() :
{}
{
  PrimaryPrefix() ( LOOKAHEAD(2) PrimarySuffix() )*
}

void PrimaryPrefix() :
{}
{
  Literal()
|  
  MathExpression()
|
  This()
|
  LOOKAHEAD( ExpressionInParentheses() )
  ExpressionInParentheses()
|
  AllocationExpression()
|
  LOOKAHEAD( MethodCall() )
  MethodCall()
|
  Identifier()
}

void This() :
{}
{
  "this"
}

void ExpressionInParentheses() :
{}
{
  "(" Expression() ")"
}

void Place() :
{}
{
  "place.places" "(" Expression() ")"
}

void FactoryBlock() :
{}
{
  "dist.factory.block" "(" Expression() ")"
}

void FactoryBlockCyclic() :
{}
{
  "dist.factory.blockCyclic" "(" Expression() "," Expression() ")"
}

void FactoryEmptyRegion() :
{}
{
  "region.factory.emptyRegion" "(" IntegerLiteral() ")"
}
 
void CurrentTime() :
{}
{
  "System.currentTimeMillis" "(" ")" 
}

void PrimarySuffix() :
{}
{
  ArrayAccess()
| 
  LOOKAHEAD(2)
  DotDistribution()
|
  LOOKAHEAD(2)
  DotRegion()
|
  LOOKAHEAD(2)
  DotId()
|
  LOOKAHEAD(3)
  DotGet()
|
  LOOKAHEAD(4)
  DotContainsPoint()
|
  LOOKAHEAD(3)
  DotContains()
|
  LOOKAHEAD(3)
  DotEquals()
|
  LOOKAHEAD(3)
  DotHigh()
|
  LOOKAHEAD(3)
  DotLow()
|
  LOOKAHEAD(3)
  DotRank()
|
  LOOKAHEAD(2)
  DotNext()
|
  LOOKAHEAD(2)
  DotPrev()
|
  LOOKAHEAD(2)
  DotIsFirst()
|
  LOOKAHEAD(2)
  DotIsLast()
|
  LOOKAHEAD(2)
  DotCoord()
|
  LOOKAHEAD(4)
  DotOrdinalPoint()
|
  LOOKAHEAD(4)
  DotOrdinal()
|
  LOOKAHEAD(2)
  DotMax()
|
  LOOKAHEAD(2)
  DotSum()
|
  LOOKAHEAD(2)
  DotSize()
|
  LOOKAHEAD( "." Identifier() "(" [ ExpressionList() ] ")" )
  DotMethodCall()
|
//  LOOKAHEAD(2)
//  DotToString()
//|
  LOOKAHEAD(2)
  DotIdentifier()
}

void ArrayAccess() :
{}
{
  "[" ExpressionList() "]"
}

void DotMethodCall() :
{}
{
  "." MethodCall()
}

void MethodCall() :
{}
{
  Identifier() "(" ( ExpressionList() )? ")"
}

void DotDistribution() :
{}
{
  "." "distribution"
}

void DotRegion() :
{}
{
  "." "region" 
}

void DotId() :
{}
{
  "." "id" 
}

void DotGet() :
{}
{
  "." "get" "(" ExpressionList() ")"
}

void DotContainsPoint() :
{}
{
  "." "contains" "(" "[" ExpressionList() "]" ")"
}

void DotContains() :
{}
{
  "." "contains" "(" Expression() ")"
}

void DotEquals() :
{}
{
  "." "equals" "(" Expression() ")"
}

void DotHigh() :
{}
{
  "." "high" "(" ")"
}

void DotLow() :
{}
{
  "." "low" "(" ")"
}

void DotRank() :
{}
{
  "." "rank" "(" Expression() ")"
}

void DotNext() :
{}
{
  "." "next" "(" ")"
}

void DotPrev() :
{}
{
  "." "prev" "(" ")"
}

void DotIsFirst() :
{}
{
  "." "isFirst" "(" ")"
}

void DotIsLast() :
{}
{
  "." "isLast" "(" ")"
}

void DotCoord() :
{}
{
  "." "coord" "(" Expression() ")" "[" IntegerLiteral() "]"
}

void DotOrdinalPoint() :
{}
{
  "." "ordinal" "(" "[" ExpressionList() "]" ")"
}

void DotOrdinal() :
{}
{
  "." "ordinal" "(" Expression() ")"
}

void DotMax() :
{}
{
  "." "max" "(" ")"
}

void DotSum() :
{}
{
  "." "sum" "(" ")"
}

void DotSize() :
{}
{
  "." "size" "(" ")"
}

void DotIdentifier() :
{}
{
  "." Identifier()
}

void AllocationExpression() :
{}
{
  LOOKAHEAD(3)
  NewObject()
|
  LOOKAHEAD( "new" NonArrayType() "value" )
  NewValueArray()
|
  LOOKAHEAD( "new" NonArrayType() "["  )
  NewUpdatableArray()
}

void NewObject() :
{}
{
 "new" Identifier() "(" [ ExpressionList() ] ")"
}

void NewValueArray() :
{}
{
 "new" NonArrayType() "value" "[" Identifier() "]" ArrayInitializer() 
}

void NewUpdatableArray() :
{}
{
 "new" NonArrayType() "[" Identifier() "]" 
  [ LOOKAHEAD( ArrayInitializer() ) ArrayInitializer() ]
}

void Literal() :
{}
{
  IntegerLiteral()
|
  LongLiteral()
|
  HexLiteral()
|
  FloatingPointLiteral()
|
  StringLiteral()
|
  True()
|
  False()
|
  HereLiteral()
|
  PlaceFirstPlace() 
|
  PlaceMaxPlaces() 
|
  DistUnique()
|
  JavaIntegerSize()
}

void IntegerLiteral() :
{}
{
  <INTEGER_LITERAL>
}

void LongLiteral() :
{}
{
  <LONG_LITERAL>
}

void HexLiteral() :
{}
{
  <HEX_LITERAL>
}

void FloatingPointLiteral() :
{}
{
  <FLOATING_POINT_LITERAL>
}

void StringLiteral() :
{}
{
  <STRING_LITERAL>
}

void True() :
{}
{
  "true"
}

void False() :
{}
{
  "false"
}

void HereLiteral() :
{}
{
  "here"
}

void PlaceFirstPlace() :
{}
{
  "place.FIRST_PLACE"
}

void PlaceMaxPlaces() :
{}
{
  "place.MAX_PLACES"
}

void DistUnique() :
{}
{
  "dist.UNIQUE"
}

void JavaIntegerSize() :
{}
{
  "java.lang.Integer.SIZE"
}

void ExpressionList() :
{}
{
  Expression() ( ArgumentRest() )*
}

void ArgumentRest() :
{}
{
  "," Expression()
}

void ArrayInitializer() :
{}
{
  "(" PointType() ExplodedSpecification() ")" Block()
}

