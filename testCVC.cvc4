OPTION "logic" "ALL";
OPTION "produce-models" true;

NodeElement: TYPE = INT;
NodeSet: TYPE = SET OF INT;

Confidentiality: TYPE = NodeSet;
B: TYPE = SET OF NodeSet;
Integrity: TYPE = B;
Availability: TYPE = B;

%set cross product
%s1 | s2 => s
ProductHelper1: (B, B, B) -> BOOLEAN = LAMBDA (b1: B, b2:B, resultB: B) : (FORALL (x, y: NodeSet): (x IS_IN b1 AND y IS_IN b2) => x | y IS_IN resultB );
ProductHelper2: (B, B, B) -> BOOLEAN = LAMBDA (b1: B, b2:B, resultB: B) : (FORALL (z: NodeSet): z IS_IN resultB => EXISTS (x, y: NodeSet): x IS_IN b1 AND y IS_IN b2 AND z = x | y);
ProductUnion: (B, B, B) -> BOOLEAN = LAMBDA (b1: B, b2:B, resultB: B) : ProductHelper1(b1, b2, resultB) AND ProductHelper2(b1, b2, resultB);

ProductHelper3: (B, B, B) -> BOOLEAN = LAMBDA (b1: B, b2:B, resultB: B) : (FORALL (x, y: NodeSet): (x IS_IN b1 AND y IS_IN b2) => x & y  IS_IN resultB );
ProductHelper4: (B, B, B) -> BOOLEAN = LAMBDA (b1: B, b2:B, resultB: B) : (FORALL (z: NodeSet): z IS_IN resultB => EXISTS (x, y: NodeSet): x IS_IN b1 AND y IS_IN b2 AND z = x & y);
ProductIntersection: (B, B, B) -> BOOLEAN = LAMBDA (b1: B, b2:B, resultB: B) : ProductHelper3(b1, b2, resultB) AND ProductHelper4(b1, b2, resultB);

%define join and meet of all the three properties seperately 
CJoin: (Confidentiality, Confidentiality) -> Confidentiality = LAMBDA (c1: Confidentiality, c2: Confidentiality) : c1 & c2;
CMeet: (Confidentiality, Confidentiality) -> Confidentiality = LAMBDA (c1: Confidentiality, c2: Confidentiality) : c1 | c2;
IJoin: (Integrity, Integrity, Integrity) -> BOOLEAN = LAMBDA (i1: Integrity, i2: Integrity, resultI: Integrity) : ProductUnion(i1, i2, resultI);
IMeet: (Integrity, Integrity, Integrity) -> BOOLEAN = LAMBDA (i1: Integrity, i2: Integrity, resultI: Integrity) : ProductIntersection(i1, i2, resultI);
AJoin: (Availability, Availability, Availability) -> BOOLEAN = LAMBDA (a1: Availability, a2: Availability, resultA: Availability) : ProductUnion(a1, a2, resultA);
AMeet: (Availability, Availability, Availability) -> BOOLEAN = LAMBDA (a1: Availability, a2: Availability, resultA: Availability) : ProductIntersection(a1, a2, resultA);

%define the >=/<= relation for the lables
CLeq: (Confidentiality, Confidentiality) -> BOOLEAN = LAMBDA (c1: Confidentiality, c2: Confidentiality) : c2 <= c1;
ILeq: (Integrity, Integrity) -> BOOLEAN = LAMBDA (i1: Integrity, i2: Integrity) : (FORALL (x: NodeSet): x IS_IN i1 => EXISTS(y: NodeSet): y IS_IN i2 AND x <= y);
ALeq: (Availability, Availability) -> BOOLEAN = LAMBDA (a1: Availability, a2: Availability) : (FORALL (x: NodeSet): x IS_IN a1 => EXISTS(y: NodeSet): y IS_IN a2 AND x <= y);

%--------------------------test for seperate set cartesain product operation-----------------------------
%x1, y1: Availability;
%ASSERT x1 = {{1, 2}, {4}};
%ASSERT y1 = {{1, 2, 3}, {4, 5}};
%QUERY ALeq(x1, y1);
%ASSERT z = {{2}, {3}, {} :: SET OF INT};
%TRANSFORM {1, 2} & {3, 8};

%ASSERT x = {{1}, {3}};
%ASSERT y = {{5}, {7}};
%ASSERT z = {{1, 5}, {1, 7}, {3, 5},  {3, 7}};
%TRANSFORM {1, 2} & {2, 3};
%TRANSFORM ProductHelper2(x, y, z);
%ASSERT ProductHelper3(x, y, z);
%--------------------------------------------------------------------------------------------------------

%define the whole lable
SecurityLable: TYPE = [# c: Confidentiality, i: Integrity, a: Availability #];
LableJoin: (SecurityLable, SecurityLable, SecurityLable) -> BOOLEAN = LAMBDA (s1: SecurityLable, s2: SecurityLable, resultS: SecurityLable) : (resultS.c = CJoin(s1.c, s2.c)) AND IMeet(s1.i, s2.i, resultS.i) AND AMeet(s1.a, s2.a, resultS.a); 
LableMeet: (SecurityLable, SecurityLable, SecurityLable) -> BOOLEAN = LAMBDA (s1: SecurityLable, s2: SecurityLable, resultS: SecurityLable) : (resultS.c = CMeet(s1.c, s2.c)) AND IJoin(s1.i, s2.i, resultS.i) AND AJoin(s1.a, s2.a, resultS.a);

%--------------------------test for whole lable operations-----------------------------
%x, y, z3: SecurityLable;
%ASSERT x = (# c := {1, 2, 3, 4, 5, 6, 7}, i := {{1, 2}, {1, 3}}, a := {{3, 4}, {2, 3}} #);
%ASSERT y = (# c := {1, 2, 3}, i := {{2, 3}}, a := {{4, 5}} #);
%ASSERT z1 = (# c := {1, 2, 3}, i := {{2}, {3}}, a := {{4}, {} :: SET OF INT} #);
%ASSERT z2 = (# c := {1, 2, 3, 4, 5, 6, 7}, i := {{1, 2, 3}}, a := {{3, 4, 5}, {2, 3, 4, 5}} #);

%TRANSFORM CJoin(x.c, y.c) = z1.c;

%QUERY LableMeet(x, y, z2);
%ASSERT LableMeet(x, y, z3);
%--------------------------------------------------------------------------------------																			

%define Integrity(Q) from this call rule
ThisCallIntegrity: (B, B) -> BOOLEAN = LAMBDA (Q: B, B1: B) : (FORALL (q, b: NodeSet): q IS_IN Q AND b IS_IN B1 => NOT(q - b = {} :: NodeSet));
AvailabilityCons: (B, B) -> BOOLEAN = LAMBDA (Q: B, B1: B) : (FORALL (b: NodeSet): b IS_IN B1 => EXISTS (q: NodeSet): q IS_IN Q AND q & b = {} :: NodeSet);
FieldIntegrity: (B, B) -> BOOLEAN = LAMBDA (Q: B, B1: B) : (FORALL (q1, q2, b: NodeSet): q1 IS_IN Q AND q2 IS_IN Q AND NOT(q1 = q2) AND b IS_IN B1 => NOT((q1 & q2) - b = {} :: NodeSet));

%--------------------------test for the constraints about this-call and field-----------------------------
q1, b1: B;
ASSERT q1 = {{1, 2}, {2, 3}};
ASSERT b1 = {{3}, {2}};
QUERY ThisCallAvailability(q1, b1);
%---------------------------------------------------------------------------------------------------------	
%CHECKSAT;
COUNTERMODEL;
